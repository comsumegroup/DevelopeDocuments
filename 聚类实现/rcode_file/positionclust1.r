#设置工作路径
#setwd("")
#example: setwd("D:/mobilecomsup/positioncode")

# select observation to analyze from txt generated by simulator 
#  11.15.2015

gdata=function(num.file,num.file.select,num.obs.each)
{
  file.ind=sample(1:num.file,size=num.file.select,replace=F)
  
  data1=read.table(paste("positionRecords_",file.ind[1],".txt",sep=""))  # paste 命令用于连接字符串
  selected.ind=sample(1:nrow(data1),num.obs.each,replace=F)
  selected.obs=data1[selected.ind, ]
  
  for(i in file.ind[-1])
  {
    datai=read.table(paste("positionRecords_",i,".txt",sep=""))
    selected.ind=sample(1:nrow(datai),num.obs.each,replace=F)
    selected.obs=rbind(selected.obs,datai[selected.ind, ])
  }
  
  return(selected.obs=selected.obs)
}


# clustering for each record in turn,then the results will be stored
# into matrix which is called "relation" in this function.

kmclust=function(selected.obs,num.group,num.peop)
{
  type.ind=rep(1:3,num.peop)
  real.group.ind=t(selected.obs[1,type.ind==1])
  
  relation=matrix(0,nrow=num.peop,ncol=num.peop)  # 创建relation矩阵
  
  for(k in 1:nrow(selected.obs))
  {
    one.obs=selected.obs[k, ]
    x_coordinate=t(one.obs[type.ind==2])
    y_coordinate=t(one.obs[type.ind==3])
    xy=cbind(x_coordinate,y_coordinate)
    rownames(xy)=1:nrow(xy)
    colnames(xy)=c("x","y")
    
    km=kmeans(xy,centers=num.group,nstart=40)  # R中的kmeans聚类命令 
    kmclust=km$clust
    
    KMCLUST1=as.matrix(kmclust)%*%rep(1,num.peop)  # 第i行所有元素都相同，表示第i个人的所属类
    KMCLUST2=matrix(1,nrow=num.peop,ncol=1)%*%kmclust # 第j列所有元素都相同，表示第j个人的所属类
    
    relation=relation+(KMCLUST1==KMCLUST2)      # (KMCLUST1==KMCLUST2) 判断第i个人和第j个人是否在同一类
    
  }
  relation=relation-diag(rep(nrow(selected.obs),num.peop))
  return(list(adjacent.matrix=relation,
              real.group.ind=real.group.ind))
}

# para settings 11.15.2015

#总的文件数
num.file=200

#每个坐标文件的记录条数
record.each.file=1000 

#选取的文件个数
num.file.select=20

#每个文件选取的记录条数
num.obs.each=10

#群组个数
num.group=150

#程序重复运行的次数
num.simulation=20

# 总人数
num.peop=ncol(read.table("positionRecords_1.txt"))/3

# simulate ,calculate average adjacent.matrix which is denoted by ADJACENCY
# simulation: 就是将数据选取和聚类的程序重复运行多次，求平均值。由于数据选取具有随机性，所以每次simulation的数据
# 都会不一样，但都是从positionRecords_txt中选取的记录

ADJACENCY=matrix(0,nrow=num.peop,ncol=num.peop)

for(i in 1:num.simulation)
{
  selected.obs=gdata(num.file=num.file,
                     num.file.select=num.file.select,
                     num.obs.each=num.obs.each)
  km.result=kmclust(selected.obs=selected.obs,num.group=num.group)
  ADJACENCY=ADJACENCY+km.result$adjacent.matrix
  if(i==1)
  {
  
    groupid=km.result$real.group.ind
  }
  
}

# 程序运行的最终结果，得到两个变量，供JAVA程序调用
ADJACENCY=ADJACENCY/num.simulation
Groupid=as.matrix(cbind(1:length(groupid),groupid))
# Groupid记录的是本次所用数据的真实分组

# 将上面两个变量输出为txt文件，供遍历算法计算准确度
# write.table(ADJACENCY,file="adjacency.txt",quote=F,row.name=F,col.names = F)
# write.table(Groupid,file="groupid.txt",quote=F,row.name=F,col.names = F)